import {
  extendTailwindMerge,
  twMerge
} from "./chunk-BTNRXTUH.js";
import "./chunk-G3PMV62Z.js";

// node_modules/tailwind-variants/dist/chunk-GQLG7IS2.js
var y = /\s+/g;
var a = (t) => typeof t != "string" || !t ? t : t.replace(y, " ").trim();
var u = (...t) => {
  let r = [], n = (e) => {
    if (!e && e !== 0 && e !== 0n) return;
    if (Array.isArray(e)) {
      for (let s = 0, o = e.length; s < o; s++) n(e[s]);
      return;
    }
    let f2 = typeof e;
    if (f2 === "string" || f2 === "number" || f2 === "bigint") {
      if (f2 === "number" && e !== e) return;
      r.push(String(e));
    } else if (f2 === "object") {
      let s = Object.keys(e);
      for (let o = 0, i2 = s.length; o < i2; o++) {
        let l = s[o];
        e[l] && r.push(l);
      }
    }
  };
  for (let e = 0, f2 = t.length; e < f2; e++) {
    let s = t[e];
    s != null && n(s);
  }
  return r.length > 0 ? a(r.join(" ")) : void 0;
};
var h = (t) => t === false ? "false" : t === true ? "true" : t === 0 ? "0" : t;
var x = (t) => {
  if (!t || typeof t != "object") return true;
  for (let r in t) return false;
  return true;
};
var k = (t, r) => {
  if (t === r) return true;
  if (!t || !r) return false;
  let n = Object.keys(t), e = Object.keys(r);
  if (n.length !== e.length) return false;
  for (let f2 = 0; f2 < n.length; f2++) {
    let s = n[f2];
    if (!e.includes(s) || t[s] !== r[s]) return false;
  }
  return true;
};
var d = (t, r) => {
  for (let n in r) if (Object.prototype.hasOwnProperty.call(r, n)) {
    let e = r[n];
    n in t ? t[n] = u(t[n], e) : t[n] = e;
  }
  return t;
};
var c = (t, r) => {
  for (let n = 0; n < t.length; n++) {
    let e = t[n];
    Array.isArray(e) ? c(e, r) : e && r.push(e);
  }
};
var g = (...t) => {
  let r = [];
  c(t, r);
  let n = [];
  for (let e = 0; e < r.length; e++) r[e] && n.push(r[e]);
  return n;
};
var p = (t, r) => {
  let n = {};
  for (let e in t) {
    let f2 = t[e];
    if (e in r) {
      let s = r[e];
      Array.isArray(f2) || Array.isArray(s) ? n[e] = g(s, f2) : typeof f2 == "object" && typeof s == "object" && f2 && s ? n[e] = p(f2, s) : n[e] = s + " " + f2;
    } else n[e] = f2;
  }
  for (let e in r) e in t || (n[e] = r[e]);
  return n;
};

// node_modules/tailwind-variants/dist/chunk-IFWU2MEM.js
var Q = { twMerge: true, twMergeConfig: {}, responsiveVariants: false };
function ne() {
  let b = null, w = {}, A = false;
  return { get cachedTwMerge() {
    return b;
  }, set cachedTwMerge(u2) {
    b = u2;
  }, get cachedTwMergeConfig() {
    return w;
  }, set cachedTwMergeConfig(u2) {
    w = u2;
  }, get didTwMergeConfigChange() {
    return A;
  }, set didTwMergeConfigChange(u2) {
    A = u2;
  }, reset() {
    b = null, w = {}, A = false;
  } };
}
var S = ne();
var le = (b$1) => {
  let w = (u2, $) => {
    let { extend: c$1 = null, slots: M = {}, variants: q = {}, compoundVariants: L = [], compoundSlots: v = [], defaultVariants: U = {} } = u2, d$1 = { ...Q, ...$ }, x2 = c$1?.base ? u(c$1.base, u2?.base) : u2?.base, p2 = c$1?.variants && !x(c$1.variants) ? p(q, c$1.variants) : q, E = c$1?.defaultVariants && !x(c$1.defaultVariants) ? { ...c$1.defaultVariants, ...U } : U;
    !x(d$1.twMergeConfig) && !k(d$1.twMergeConfig, S.cachedTwMergeConfig) && (S.didTwMergeConfigChange = true, S.cachedTwMergeConfig = d$1.twMergeConfig);
    let N = x(c$1?.slots), O = x(M) ? {} : { base: u(u2?.base, N && c$1?.base), ...M }, j$1 = N ? O : d({ ...c$1?.slots }, x(O) ? { base: u2?.base } : O), T2 = x(c$1?.compoundVariants) ? L : g(c$1?.compoundVariants, L), y2 = (h2) => {
      if (x(p2) && x(M) && N) return b$1(x2, h2?.class, h2?.className)(d$1);
      if (T2 && !Array.isArray(T2)) throw new TypeError(`The "compoundVariants" prop must be an array. Received: ${typeof T2}`);
      if (v && !Array.isArray(v)) throw new TypeError(`The "compoundSlots" prop must be an array. Received: ${typeof v}`);
      let Y = (t, e, n = [], a$1) => {
        let r = n;
        if (typeof e == "string") {
          let i2 = a(e).split(" ");
          for (let l = 0; l < i2.length; l++) r.push(`${t}:${i2[l]}`);
        } else if (Array.isArray(e)) for (let s = 0; s < e.length; s++) r.push(`${t}:${e[s]}`);
        else if (typeof e == "object" && typeof a$1 == "string" && a$1 in e) {
          let s = e[a$1];
          if (s && typeof s == "string") {
            let l = a(s).split(" "), f2 = [];
            for (let o = 0; o < l.length; o++) f2.push(`${t}:${l[o]}`);
            r[a$1] = r[a$1] ? r[a$1].concat(f2) : f2;
          } else if (Array.isArray(s) && s.length > 0) {
            let i2 = [];
            for (let l = 0; l < s.length; l++) i2.push(`${t}:${s[l]}`);
            r[a$1] = i2;
          }
        }
        return r;
      }, W = (t, e = p2, n = null, a2 = null) => {
        let r = e[t];
        if (!r || x(r)) return null;
        let s = a2?.[t] ?? h2?.[t];
        if (s === null) return null;
        let i2 = h(s), l = Array.isArray(d$1.responsiveVariants) && d$1.responsiveVariants.length > 0 || d$1.responsiveVariants === true, f2 = E?.[t], o = [];
        if (typeof i2 == "object" && l) for (let [C2, H] of Object.entries(i2)) {
          let te = r[H];
          if (C2 === "initial") {
            f2 = H;
            continue;
          }
          Array.isArray(d$1.responsiveVariants) && !d$1.responsiveVariants.includes(C2) || (o = Y(C2, te, o, n));
        }
        let V = i2 != null && typeof i2 != "object" ? i2 : h(f2), m = r[V || "false"];
        return typeof o == "object" && typeof n == "string" && o[n] ? d(o, m) : o.length > 0 ? (o.push(m), n === "base" ? o.join(" ") : o) : m;
      }, Z = () => {
        if (!p2) return null;
        let t = Object.keys(p2), e = [];
        for (let n = 0; n < t.length; n++) {
          let a2 = W(t[n], p2);
          a2 && e.push(a2);
        }
        return e;
      }, _ = (t, e) => {
        if (!p2 || typeof p2 != "object") return null;
        let n = [];
        for (let a2 in p2) {
          let r = W(a2, p2, t, e), s = t === "base" && typeof r == "string" ? r : r && r[t];
          s && n.push(s);
        }
        return n;
      }, z = {};
      for (let t in h2) {
        let e = h2[t];
        e !== void 0 && (z[t] = e);
      }
      let D = (t, e) => {
        let n = typeof h2?.[t] == "object" ? { [t]: h2[t]?.initial } : {};
        return { ...E, ...z, ...n, ...e };
      }, G = (t = [], e) => {
        let n = [], a2 = t.length;
        for (let r = 0; r < a2; r++) {
          let { class: s, className: i2, ...l } = t[r], f2 = true, o = D(null, e);
          for (let V in l) {
            let m = l[V], C2 = o[V];
            if (Array.isArray(m)) {
              if (!m.includes(C2)) {
                f2 = false;
                break;
              }
            } else {
              if ((m == null || m === false) && (C2 == null || C2 === false)) continue;
              if (C2 !== m) {
                f2 = false;
                break;
              }
            }
          }
          f2 && (s && n.push(s), i2 && n.push(i2));
        }
        return n;
      }, K = (t) => {
        let e = G(T2, t);
        if (!Array.isArray(e)) return e;
        let n = {}, a2 = b$1;
        for (let r = 0; r < e.length; r++) {
          let s = e[r];
          if (typeof s == "string") n.base = a2(n.base, s)(d$1);
          else if (typeof s == "object") for (let i2 in s) n[i2] = a2(n[i2], s[i2])(d$1);
        }
        return n;
      }, ee = (t) => {
        if (v.length < 1) return null;
        let e = {}, n = D(null, t);
        for (let a2 = 0; a2 < v.length; a2++) {
          let { slots: r = [], class: s, className: i2, ...l } = v[a2];
          if (!x(l)) {
            let f2 = true;
            for (let o in l) {
              let V = n[o], m = l[o];
              if (V === void 0 || (Array.isArray(m) ? !m.includes(V) : m !== V)) {
                f2 = false;
                break;
              }
            }
            if (!f2) continue;
          }
          for (let f2 = 0; f2 < r.length; f2++) {
            let o = r[f2];
            e[o] || (e[o] = []), e[o].push([s, i2]);
          }
        }
        return e;
      };
      if (!x(M) || !N) {
        let t = {};
        if (typeof j$1 == "object" && !x(j$1)) {
          let e = b$1;
          for (let n in j$1) t[n] = (a2) => {
            let r = K(a2), s = ee(a2);
            return e(j$1[n], _(n, a2), r ? r[n] : void 0, s ? s[n] : void 0, a2?.class, a2?.className)(d$1);
          };
        }
        return t;
      }
      return b$1(x2, Z(), G(T2), h2?.class, h2?.className)(d$1);
    }, X = () => {
      if (!(!p2 || typeof p2 != "object")) return Object.keys(p2);
    };
    return y2.variantKeys = X(), y2.extend = c$1, y2.base = x2, y2.slots = j$1, y2.variants = p2, y2.defaultVariants = E, y2.compoundSlots = v, y2.compoundVariants = T2, y2;
  };
  return { tv: w, createTV: (u2) => ($, c2) => w($, c2 ? p(u2, c2) : u2) };
};

// node_modules/tailwind-variants/dist/index.js
var f = (e) => x(e) ? twMerge : extendTailwindMerge({ ...e, extend: { theme: e.theme, classGroups: e.classGroups, conflictingClassGroupModifiers: e.conflictingClassGroupModifiers, conflictingClassGroups: e.conflictingClassGroups, ...e.extend } });
var i = (...e) => (a2) => {
  let t = u(e);
  return !t || !a2.twMerge ? t : ((!S.cachedTwMerge || S.didTwMergeConfigChange) && (S.didTwMergeConfigChange = false, S.cachedTwMerge = f(S.cachedTwMergeConfig)), S.cachedTwMerge(t) || void 0);
};
var { createTV: C, tv: T } = le(i);
export {
  i as cn,
  u as cnBase,
  C as createTV,
  Q as defaultConfig,
  T as tv
};
//# sourceMappingURL=tailwind-variants.js.map
