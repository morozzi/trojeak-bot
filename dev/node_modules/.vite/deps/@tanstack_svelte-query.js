import "./chunk-2HXDZ22R.js";
import "./chunk-DM4AGAYI.js";
import "./chunk-ELKJSBLM.js";
import {
  CancelledError,
  InfiniteQueryObserver,
  Mutation,
  MutationCache,
  MutationObserver,
  QueriesObserver,
  Query,
  QueryCache,
  QueryClient,
  QueryObserver,
  dataTagErrorSymbol,
  dataTagSymbol,
  defaultScheduler,
  defaultShouldDehydrateMutation,
  defaultShouldDehydrateQuery,
  dehydrate,
  focusManager,
  hashKey,
  hydrate,
  isCancelledError,
  isServer,
  keepPreviousData,
  matchMutation,
  matchQuery,
  noop,
  notifyManager,
  onlineManager,
  partialMatchKey,
  replaceEqualDeep,
  shouldThrowError,
  skipToken,
  streamedQuery,
  timeoutManager,
  unsetMarker
} from "./chunk-HK5R4IU6.js";
import {
  check_target,
  derived,
  get,
  hmr,
  init,
  legacy_api,
  onDestroy,
  onMount,
  prop,
  readable,
  slot
} from "./chunk-BBZFQ53V.js";
import "./chunk-U7P2NEEE.js";
import {
  append,
  comment
} from "./chunk-5CZJDXBM.js";
import {
  FILENAME,
  HMR,
  first_child,
  getContext,
  pop,
  push,
  set,
  setContext
} from "./chunk-4WNWHWIS.js";
import "./chunk-L3IDHH4W.js";
import "./chunk-K63UQA3V.js";
import "./chunk-G3PMV62Z.js";

// node_modules/@tanstack/svelte-query/dist/context.js
var _contextKey = "$$_queryClient";
var getQueryClientContext = () => {
  const client = getContext(_contextKey);
  if (!client) {
    throw new Error("No QueryClient was found in Svelte context. Did you forget to wrap your component with QueryClientProvider?");
  }
  return client;
};
var setQueryClientContext = (client) => {
  setContext(_contextKey, client);
};
var _isRestoringContextKey = "$$_isRestoring";
var getIsRestoringContext = () => {
  try {
    const isRestoring = getContext(_isRestoringContextKey);
    return isRestoring ? isRestoring : readable(false);
  } catch (error) {
    return readable(false);
  }
};
var setIsRestoringContext = (isRestoring) => {
  setContext(_isRestoringContextKey, isRestoring);
};

// node_modules/@tanstack/svelte-query/dist/useIsRestoring.js
function useIsRestoring() {
  return getIsRestoringContext();
}

// node_modules/@tanstack/svelte-query/dist/useQueryClient.js
function useQueryClient(queryClient) {
  if (queryClient)
    return queryClient;
  return getQueryClientContext();
}

// node_modules/@tanstack/svelte-query/dist/utils.js
function isSvelteStore(obj) {
  return "subscribe" in obj && typeof obj.subscribe === "function";
}

// node_modules/@tanstack/svelte-query/dist/createBaseQuery.js
function createBaseQuery(options, Observer, queryClient) {
  const client = useQueryClient(queryClient);
  const isRestoring = useIsRestoring();
  const optionsStore = isSvelteStore(options) ? options : readable(options);
  const defaultedOptionsStore = derived([optionsStore, isRestoring], ([$optionsStore, $isRestoring]) => {
    const defaultedOptions = client.defaultQueryOptions($optionsStore);
    defaultedOptions._optimisticResults = $isRestoring ? "isRestoring" : "optimistic";
    return defaultedOptions;
  });
  const observer = new Observer(client, get(defaultedOptionsStore));
  defaultedOptionsStore.subscribe(($defaultedOptions) => {
    observer.setOptions($defaultedOptions);
  });
  const result = derived(isRestoring, ($isRestoring, set2) => {
    const unsubscribe = $isRestoring ? noop : observer.subscribe(notifyManager.batchCalls(set2));
    observer.updateResult();
    return unsubscribe;
  });
  const { subscribe } = derived([result, defaultedOptionsStore], ([$result, $defaultedOptionsStore]) => {
    $result = observer.getOptimisticResult($defaultedOptionsStore);
    return !$defaultedOptionsStore.notifyOnChangeProps ? observer.trackResult($result) : $result;
  });
  return { subscribe };
}

// node_modules/@tanstack/svelte-query/dist/createQuery.js
function createQuery(options, queryClient) {
  return createBaseQuery(options, QueryObserver, queryClient);
}

// node_modules/@tanstack/svelte-query/dist/queryOptions.js
function queryOptions(options) {
  return options;
}

// node_modules/@tanstack/svelte-query/dist/createQueries.js
function createQueries({ queries, ...options }, queryClient) {
  const client = useQueryClient(queryClient);
  const isRestoring = useIsRestoring();
  const queriesStore = isSvelteStore(queries) ? queries : readable(queries);
  const defaultedQueriesStore = derived([queriesStore, isRestoring], ([$queries, $isRestoring]) => {
    return $queries.map((opts) => {
      const defaultedOptions = client.defaultQueryOptions(opts);
      defaultedOptions._optimisticResults = $isRestoring ? "isRestoring" : "optimistic";
      return defaultedOptions;
    });
  });
  const observer = new QueriesObserver(client, get(defaultedQueriesStore), options);
  defaultedQueriesStore.subscribe(($defaultedQueries) => {
    observer.setQueries($defaultedQueries, options);
  });
  const result = derived([isRestoring], ([$isRestoring], set2) => {
    const unsubscribe = $isRestoring ? noop : observer.subscribe(notifyManager.batchCalls(set2));
    return () => unsubscribe();
  });
  const { subscribe } = derived(
    [result, defaultedQueriesStore],
    // @ts-expect-error svelte-check thinks this is unused
    ([$result, $defaultedQueriesStore]) => {
      const [rawResult, combineResult, trackResult] = observer.getOptimisticResult($defaultedQueriesStore, options.combine);
      $result = rawResult;
      return combineResult(trackResult());
    }
  );
  return { subscribe };
}

// node_modules/@tanstack/svelte-query/dist/createInfiniteQuery.js
function createInfiniteQuery(options, queryClient) {
  return createBaseQuery(options, InfiniteQueryObserver, queryClient);
}

// node_modules/@tanstack/svelte-query/dist/infiniteQueryOptions.js
function infiniteQueryOptions(options) {
  return options;
}

// node_modules/@tanstack/svelte-query/dist/createMutation.js
function createMutation(options, queryClient) {
  const client = useQueryClient(queryClient);
  const optionsStore = isSvelteStore(options) ? options : readable(options);
  const observer = new MutationObserver(client, get(optionsStore));
  let mutate;
  optionsStore.subscribe(($options) => {
    mutate = (variables, mutateOptions) => {
      observer.mutate(variables, mutateOptions).catch(noop);
    };
    observer.setOptions($options);
  });
  const result = readable(observer.getCurrentResult(), (set2) => {
    return observer.subscribe(notifyManager.batchCalls((val) => set2(val)));
  });
  const { subscribe } = derived(result, ($result) => ({
    ...$result,
    mutate,
    mutateAsync: $result.mutate
  }));
  return { subscribe };
}

// node_modules/@tanstack/svelte-query/dist/useMutationState.js
function getResult(mutationCache, options) {
  return mutationCache.findAll(options.filters).map((mutation) => options.select ? options.select(mutation) : mutation.state);
}
function useMutationState(options = {}, queryClient) {
  const client = useQueryClient(queryClient);
  const mutationCache = client.getMutationCache();
  let result = getResult(mutationCache, options);
  const { subscribe } = readable(result, (set2) => {
    return mutationCache.subscribe(notifyManager.batchCalls(() => {
      const nextResult = replaceEqualDeep(result, getResult(mutationCache, options));
      if (result !== nextResult) {
        result = nextResult;
        set2(result);
      }
    }));
  });
  return { subscribe };
}

// node_modules/@tanstack/svelte-query/dist/useIsFetching.js
function useIsFetching(filters, queryClient) {
  const client = useQueryClient(queryClient);
  const cache = client.getQueryCache();
  let isFetching = client.isFetching(filters);
  const { subscribe } = readable(isFetching, (set2) => {
    return cache.subscribe(notifyManager.batchCalls(() => {
      const newIsFetching = client.isFetching(filters);
      if (isFetching !== newIsFetching) {
        isFetching = newIsFetching;
        set2(isFetching);
      }
    }));
  });
  return { subscribe };
}

// node_modules/@tanstack/svelte-query/dist/useIsMutating.js
function useIsMutating(filters, queryClient) {
  const client = useQueryClient(queryClient);
  const cache = client.getMutationCache();
  let isMutating = client.isMutating(filters);
  const { subscribe } = readable(isMutating, (set2) => {
    return cache.subscribe(notifyManager.batchCalls(() => {
      const newIisMutating = client.isMutating(filters);
      if (isMutating !== newIisMutating) {
        isMutating = newIisMutating;
        set2(isMutating);
      }
    }));
  });
  return { subscribe };
}

// node_modules/@tanstack/svelte-query/dist/useHydrate.js
function useHydrate(state, options, queryClient) {
  const client = useQueryClient(queryClient);
  if (state) {
    hydrate(client, state, options);
  }
}

// node_modules/@tanstack/svelte-query/dist/HydrationBoundary.svelte
HydrationBoundary[FILENAME] = "node_modules/@tanstack/svelte-query/dist/HydrationBoundary.svelte";
function HydrationBoundary($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, HydrationBoundary);
  let state = prop($$props, "state", 8);
  let options = prop($$props, "options", 8, void 0);
  let queryClient = prop($$props, "queryClient", 8, void 0);
  useHydrate(state(), options(), queryClient());
  var $$exports = { ...legacy_api() };
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(node, $$props, "default", {}, null);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  HydrationBoundary = hmr(HydrationBoundary, () => HydrationBoundary[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = HydrationBoundary[HMR].source;
    set(HydrationBoundary[HMR].source, module.default[HMR].original);
  });
}
var HydrationBoundary_default = HydrationBoundary;

// node_modules/@tanstack/svelte-query/dist/QueryClientProvider.svelte
QueryClientProvider[FILENAME] = "node_modules/@tanstack/svelte-query/dist/QueryClientProvider.svelte";
function QueryClientProvider($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, QueryClientProvider);
  let client = prop($$props, "client", 24, () => new QueryClient());
  onMount(() => {
    client().mount();
  });
  setQueryClientContext(client());
  onDestroy(() => {
    client().unmount();
  });
  var $$exports = { ...legacy_api() };
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(node, $$props, "default", {}, null);
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  QueryClientProvider = hmr(QueryClientProvider, () => QueryClientProvider[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = QueryClientProvider[HMR].source;
    set(QueryClientProvider[HMR].source, module.default[HMR].original);
  });
}
var QueryClientProvider_default = QueryClientProvider;
export {
  CancelledError,
  HydrationBoundary_default as HydrationBoundary,
  InfiniteQueryObserver,
  Mutation,
  MutationCache,
  MutationObserver,
  QueriesObserver,
  Query,
  QueryCache,
  QueryClient,
  QueryClientProvider_default as QueryClientProvider,
  QueryObserver,
  createInfiniteQuery,
  createMutation,
  createQueries,
  createQuery,
  dataTagErrorSymbol,
  dataTagSymbol,
  defaultScheduler,
  defaultShouldDehydrateMutation,
  defaultShouldDehydrateQuery,
  dehydrate,
  streamedQuery as experimental_streamedQuery,
  focusManager,
  getIsRestoringContext,
  getQueryClientContext,
  hashKey,
  hydrate,
  infiniteQueryOptions,
  isCancelledError,
  isServer,
  keepPreviousData,
  matchMutation,
  matchQuery,
  noop,
  notifyManager,
  onlineManager,
  partialMatchKey,
  queryOptions,
  replaceEqualDeep,
  setIsRestoringContext,
  setQueryClientContext,
  shouldThrowError,
  skipToken,
  timeoutManager,
  unsetMarker,
  useHydrate,
  useIsFetching,
  useIsMutating,
  useIsRestoring,
  useMutationState,
  useQueryClient
};
//# sourceMappingURL=@tanstack_svelte-query.js.map
